<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="Port.Logger">
<Super>%RegisteredObject</Super>
<TimeCreated>64306,37945.966346</TimeCreated>

<Property name="LogLevel">
<Type>%Integer</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>logLevel:%Integer=2</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..LogLevel = logLevel
  quit $$$OK
]]></Implementation>
</Method>

<Method name="Log">
<FormalSpec>message:%String,messageLogLevel=2,params...:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ..LogLevel = -1 set ..LogLevel = 0
  #define CRLF $char(13, 10)
  
  if '$data(params) set params = 0  
  
  set msg = message
  
  if messageLogLevel <= ..LogLevel {
    for i=1:1:params {
      set msg = $replace(msg, "{P"_i_"}", params(i))
    }
    set msg = $replace(msg, "[nl]", $$$CRLF)
    write msg
  }
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Backup">
<Super>%RegisteredObject</Super>
<TimeCreated>64306,37561.640431</TimeCreated>

<Property name="BackupDirectory">
<Type>%String</Type>
</Property>

<Property name="Logger">
<Type>Port.Project.Importer</Type>
</Property>

<Property name="IsRequired">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ImportList">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%OnNew">
<FormalSpec>backupDir:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..BackupDirectory = backupDir
  quit $$$OK
]]></Implementation>
</Method>

<Method name="Create">
<FormalSpec><![CDATA[&list:%String=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set sc = $$$OK
  set itemName = ""
  set backupCount = 0
  set appPath = $System.CSP.GetDefaultApp($namespace)
  set appPath = $extract(appPath, 2, $length(appPath))
  set backupFolderIsCreated = 0
  
  if '..IsRequired quit $$$OK
  
  do ..Logger.Log("Starting backup ... [nl]DO NOT INTERRUPT THIS PROCESS![nl]", 1)
  do ..Logger.Log("Mirroring structure to temporary directory ... ", 1)
  
  do Walkthrough(9,  "CSR")
  do Walkthrough(10, "CSP")
  
  if $$$ISOK(sc) do ..Logger.Log(" done.", 1)
  else  do ..Logger.Log(" done with errors!", 1)
  do ..Logger.Log("[nl][nl]", 1)
  quit sc  


Walkthrough(group, type)
  set itemName = ""   
  for {
    set itemName = $order(list(group, type, itemName), 1, paths)
    quit:itemName=""
    
    set backupOrigin = $listget(paths, 2)
    set newVersion = $listget(paths, 1)
    // TODO: Add extra check to avoid backing up files that are not really outdated.
    // Don't backup or remove anything if target file is not present in the project
    // or doesn't exists in the app.
    if '(##class(%File).Exists(backupOrigin) && ##class(%File).Exists(newVersion)) {
      continue
    }
    set backupDestination = ##class(%File).NormalizeFilename(..BackupDirectory_"/"_$replace(itemName, appPath, ""))
    set parentBackupDirectory = ##class(%File).GetDirectory(backupDestination)
    set sc = ##class(Port.Project.Helper).ImplyDirectoryCreation(parentBackupDirectory)
    if $$$ISERR(sc) quit
    
    set backupFolderIsCreated = 1
    
    set isCopied = ##class(%File).CopyFile(backupOrigin, backupDestination, 1)
    set isDeleted = ##class(%File).Delete(backupOrigin)
    if isCopied = 0 || (isDeleted = 0) {
      set sc = $$$ADDSC(sc, $$$ERROR($$$GeneralError, "Unable to copy "_itemName_" to backup destination. Aborting."))
    }   
  }
  if 'backupFolderIsCreated set ..IsRequired = 0
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Base">
<IncludeCode>portutils</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64306,34528.425857</TimeCreated>

<Property name="Logger">
<Type>Port.Logger</Type>
<Private>1</Private>
</Property>

<Property name="ProjectName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Project">
<Type>%Studio.Project</Type>
<Private>1</Private>
</Property>

<Property name="Slash">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="BasePath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="IncPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ClassPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="IntPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="MacPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="WebPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="MvbPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="MviPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="BasPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="DfiPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="AffectedCount">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="VCS">
<Type>Port.SourceControl.Extension.VCS</Type>
</Property>

<Property name="IsBatch">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Overwrite">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="LogLevel">
<Type>%Integer</Type>
<InitialExpression>2</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>target:%String,logLevel:%Integer=2</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if target = "" {
    throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR(5001, "No target specified."))
  }
  
  set ..Slash = $select($$$isWINDOWS : "\", 1: "/")
  
  if (target [ "/") || (target [ "\") {
    set fullProjectPath = ##class(%File).NormalizeFilename(target)          
    set partsLength = $length(fullProjectPath, ..Slash) 
    
    set ..ProjectName = $piece(fullProjectPath, ..Slash, partsLength, partsLength)        
    set ..BasePath = ##class(%File).NormalizeFilename(fullProjectPath)
    set ..Project = ##class(%Studio.Project).%OpenId(..ProjectName)
    set ..Logger = ##class(Port.Logger).%New(logLevel)
    do ..BuildTypePaths(..BasePath)
    quit $$$OK 
  }
  throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR(5001, "Utility requires an absolute path."))
]]></Implementation>
</Method>

<Method name="WriteExclusive">
<FormalSpec>logLevel:%Integer,message:%String,params...:%String</FormalSpec>
<Implementation><![CDATA[
  if ..Logger.LogLevel '= logLevel quit
  do ..Write(message, logLevel, params...)
]]></Implementation>
</Method>

<Method name="Write">
<FormalSpec>message:%Boolean,logLevel:%Integer=1,params...:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[  do ..Logger.Log(message, logLevel, params...)
]]></Implementation>
</Method>

<Method name="GetProjectName">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  quit ..ProjectName
]]></Implementation>
</Method>

<Method name="ResolvePathType">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>itemType:%String,itemName:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  #define Normalize(%path)    ##class(%File).NormalizeFilename(%path)
  
  if itemType = "CLS" quit ..ClassPath
  if itemType = "INT" quit ..IntPath
  if itemType = "INC" || (itemType = "MAC" && ($piece(itemName, ".", 2) = "INC")) {
    // No idea why InterSystems groups INC into MAC type, so we patch it checking the name instead.
    quit ..IncPath
  }
  if itemType = "MAC" quit ..MacPath
  if itemType = "CSP" quit ..WebPath
  if itemType = "MVB" quit ..MvbPath
  if itemType = "MVI" quit ..MviPath  
  if itemType = "BAS" quit ..BasPath
  if itemType = "DFI" quit ..DfiPath
  quit ""
]]></Implementation>
</Method>

<Method name="BuildTypePaths">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>workingDirectory:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #define BuildTypedPath(%type) $lts($lb(workingDirectory, %type), ..Slash)
  
  set ..ClassPath = $$$BuildTypedPath("cls")
  set ..IntPath   = $$$BuildTypedPath("int")
  set ..MacPath   = $$$BuildTypedPath("mac") 
  set ..IncPath   = $$$BuildTypedPath("inc")
  set ..WebPath   = $$$BuildTypedPath("web")  
  set ..MvbPath   = $$$BuildTypedPath("mvb")
  set ..MviPath   = $$$BuildTypedPath("mvi")
  set ..BasPath   = $$$BuildTypedPath("bas")  
  set ..DfiPath   = $$$BuildTypedPath("dfi")
  quit $$$OK
]]></Implementation>
</Method>

<Method name="NormalizeOutput">
<FormalSpec>itemName:%String,*path:%String="",*extension:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  set extension = ##class(Port.Project.Helper).GetItemExtension(itemName)
  set dest = ""
  
  // Package.Class.Name -> cls/Package/Class/Name.cls.txt
  if extension = "CLS" {
    set classBasePath = ..ResolvePathType("CLS")
    set classItemName = $piece(itemName, ".", 1, $length(itemName, ".") - 1)
    set classPath = $listtostring($listbuild(classBasePath, $replace(classItemName, ".", ..Slash)), ..Slash)
    set packagePath = $piece(classPath, ..Slash, 1, $length(classPath, ..Slash) - 1)
    set className = $piece(classPath, ..Slash, $length(classPath, ..Slash))
    set dest = classPath_".cls.txt"
    set path = packagePath
  }
  
  // Routine.(type) -> /(type)/routine.(type).txt
  elseif ##class(Port.Project.Helper).IsRoutine(itemName) {    
    set type = $$$ucase($piece(itemName, ".", $length(itemName, ".")))
    set path = ..ResolvePathType(type, itemName)
    set dest = path_..Slash_itemName
    set extPos = $length(dest, ".")
    set $piece(dest, ".", extPos) = $$$lcase($piece(dest, ".", extPos))_".txt"
  }
  
  // /csp/path/to/somefile.(*) -> /web/path/to/somefile.(*).txt
  else {
    set appPath = $System.CSP.GetDefaultApp($namespace)
    set baseTypePath = ..ResolvePathType("CSP")
    set ext = $$$lcase($piece(itemName, ".", $length(itemName, ".")))
    set fileWithoutExtension = $piece(itemName, ".", 1, $length(itemName, ".") -1)
    set dest = ##class(%File).NormalizeFilename(baseTypePath_..Slash_$piece(fileWithoutExtension, "/", 3, $length(fileWithoutExtension, "/")))_"."_ext
    set path = ##class(%File).GetDirectory(dest) 
  }
  quit dest
]]></Implementation>
</Method>

<Method name="AttemptToCallVCSMethod">
<FormalSpec>methodName,params...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ..IsVCSEnabled() {
    quit $method(..VCS, methodName, params...)
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckUbiquity">
<FormalSpec><![CDATA[&ubiquityList:%String=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set (name, type, projects) = ""
  
  set sProjects = ##class(%SQL.Statement).%New()
  $$$QuitOnError(sProjects.%PrepareClassQuery("%Studio.Project", "ProjectList"))   
  set projectRows = sProjects.%Execute()
  
  set sProjectItems = ##class(%SQL.Statement).%New()
  $$$QuitOnError(sProjectItems.%PrepareClassQuery("%Studio.Project", "ProjectItemsList"))
  set projectItemsRows = sProjectItems.%Execute(..Project.Name)
  
  while projectRows.%Next(.sc) {
    if $$$ISERR(sc) quit
    set projectName = projectRows.%Get("Name")
    if projectName '= ..Project.Name {
      set projects(projectName) = ""     
    }
  }
  
  while projectItemsRows.%Next(.sc) {
    if $$$ISERR(sc) quit
    set id = projectItemsRows.%Get("ID")
    set type = projectItemsRows.%Get("Type")    
    set name = projectItemsRows.%Get("Name")
    set candidateId = id
    set candidateProject = ""
    for {      
      set candidateProject = $order(projects(candidateProject))
      quit:candidateProject=""
      set candidateId = id
      set $piece(candidateId, "||", 1) = candidateProject
      if ##class(%Studio.ProjectItem).%ExistsId(candidateId) {
        set ubiquityList = ubiquityList + 1
        set ubiquityList(candidateId) = $listbuild(projectName, name, type)
      } elseif type = "CLS" {
        set class = ""
        set parts = $length(name, ".")
        set $piece(candidateId, "||", 3) = "PKG"
        for i=parts:-1:1 {
          set class = $piece(name,  ".", 1, i)
          set $piece(candidateId, "||", 2) = class
          if ##class(%Studio.ProjectItem).%ExistsId(candidateId) {
            set ubiquityList = ubiquityList + 1
            set ubiquityList(candidateId) = ""
            quit
          }
        }
      }
    }    
  }
]]></Implementation>
</Method>

<Method name="IsVCSEnabled">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit $isobject(..VCS) && ($classname(..VCS) '= "Port.SourceControl.Extension.VCS")
]]></Implementation>
</Method>

<Method name="IsOutdated">
<FormalSpec>resident:%String,contestant:%String,isImport:%Boolean=0,*isCompilationCandidate:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  
  if '##class(%File).Exists(contestant) quit 1 
  set contestantTS = $zdt(##class(%File).GetFileDateModified(##class(%File).NormalizeFilename(contestant)), 3,,,,,,,,,0)
  
  if contestantTS < 0 quit 1
  set lastModified = 0
  
  set projectTS = ##class(Port.SourceControl.Log).GetLastChange(..GetProjectName(), ..GetProjectName()_".PRJ")
  set residentDate = ##class(Port.SourceControl.Log).GetLastChange(..GetProjectName(), resident)
  
  if residentDate = 0 set lastModified = projectTS
  else  set lastModified = $select(residentDate ] projectTS : residentDate, 1: projectTS)
    
  if ##class(Port.Project.Helper).IsRoutine(resident) || 
    (##class(Port.Project.Helper).GetItemExtension(resident) = "CLS") {
    set residentTS = $piece(##class(%RoutineMgr).TS(resident, .compileTime, .upToDate), ".")   
    set isCompilationCandidate = 'upToDate
  } else {
    if 'isImport {
      set fullSourcePath = ##class(%File).NormalizeFilename(resident, $System.Util.InstallDirectory())
    } else {
      set fullSourcePath = ##class(Port.Project.Helper).CSPToAbsoluteAppPath(resident)
    }
    set residentTS = $zdatetime(##class(%File).GetFileDateModified(fullSourcePath), 3,,,,,,,,,0)
    // If the file is missing it's considered outdated as well.
    if residentTS = 0 quit 1
  }
  // Same date for both entries? Then consider updated.
  if residentTS = contestantTS quit 0
  if 'isImport {  
    quit (
      (residentTS ] contestantTS) && 
      (residentTS ] lastModified)
    )
  }
  quit (
    (contestantTS ] residentTS) && 
    (contestantTS ] lastModified)
  )
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Exporter">
<Super>Port.Project.Base</Super>
<TimeCreated>64306,34528.610794</TimeCreated>

<Property name="Project">
<Type>%Studio.Project</Type>
<Private>1</Private>
</Property>

<Property name="Overwrite">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="PathDependencies">
<Type>%String</Type>
<Collection>array</Collection>
<Private>1</Private>
</Property>

<Property name="ExportedPackages">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>path:%String,logLevel:%Integer=2</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ##super(path, logLevel)
  
  if '$isobject(..Project) {
    set ..ProjectName = "null"
    throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR(5001, "Invalid project name ("_..ProjectName_")."))
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="Export">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ..Project.Items.Count() = 0 {
    do ..Write("[nl]No items to export. Aborting ... [nl] ", 0)
    quit $$$OK
  }
  
  set ..IsBatch = 1
  
  do ..Write("[nl]Exporting project {P1} ...", 0, ..Project.Name)
  set cspDirectory = ##class(%File).NormalizeFilename($System.Util.InstallDirectory()_"csp/"_$$$lcase($namespace))
  
  $$$QuitOnError(##class(Port.Project.Helper).ImplyDirectoryCreation(cspDirectory))
  $$$QuitOnError(..ExportProjectItems(.exportList))
  
  if ..AffectedCount > 0 {
    do ..Write("[nl]Files were exported to path {P1}.", 0, ..BasePath)
  } else {
    do ..Write("[nl]No files were exported, project {P1} might be empty or repository is up-to-date.", 0, ..Project.Name)
  }
  
  do ..Write("[nl]Synchronizing ...[nl]", 0)
  $$$QuitOnError(..PurgeExtraneousEntries())
  
  do ..Write("All done.[nl]", 0)
  
  if ..IsVCSEnabled() && ($listlength(exportList) > 0) {
    do ..AttemptToCallVCSMethod("OnExport", ..VCS.#PATHS) 
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="SearchExtraneousEntries">
<FormalSpec><![CDATA[statement:%SQL.Statement,path:%String,&files:%String=""]]></FormalSpec>
<Implementation><![CDATA[
  set dir = ##class(%File).NormalizeDirectory(path)
  set row = statement.%Execute(dir)
  set sc = $$$OK  
  
  while row.%Next(.sc) {
    set type = row.%Get("Type")
    set fullPath = row.%Get("Name")
    if '..PathDependencies.IsDefined(fullPath) {
      set length = $case(files, "": 1, : $listlength(files)+1)
      set $list(files, length) = $listbuild(fullPath, type) 
    }
    if type = "D" set sc = ..SearchExtraneousEntries(statement, fullPath, .files)
    if $$$ISERR(sc) quit
  }
  quit sc
]]></Implementation>
</Method>

<Method name="PurgeExtraneousEntries">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set s = ##class(%SQL.Statement).%New()
  $$$QuitOnError(s.%PrepareClassQuery("%File", "FileSet"))
  set removedDirectories = ""
  set lastParent = ""
  set parentDirectory = ""
  
  do ..Write("Checking for extraneous files or directories ...")
  
  for ipath = ..MacPath,..IntPath,..IncPath,..ClassPath,..WebPath,..MvbPath,..MviPath,..DfiPath {
    set sc = ..SearchExtraneousEntries(s, ipath, .extraneousFiles)
    if $$$ISERR(sc) quit
  }
  
  $$$QuitOnError(sc)
  
  set length = $listlength(extraneousFiles)
  if length > 0 do ..Write(" found {P1} extraneous item{P2}.[nl]", 1, length, $case(length, 1: "", : "s"))
  else  do ..Write(" no extraneous items were found.[nl]", 1)
  
  for i=1:1:length {
    set possiblyDeleted = 0
    set extraneousItem = $listget(extraneousFiles, i)
    set path = $listget(extraneousItem, 1)
    set type = $listget(extraneousItem, 2)
    if parentDirectory '= "" && (path [ parentDirectory) set possiblyDeleted = 1
    if type = "F" && ##class(%File).Exists(path) {
      set fileName = ##class(%File).GetFilename(path)
      set lastNode = ##class(%File).GetDirectoryPiece(parentDirectory, $length(parentDirectory, ..Slash))
      set fileName = $piece(fileName, ".", 1)           
      if fileName = lastNode set possiblyDeleted = 0 
      if possiblyDeleted = 1 continue
      do ..Write("Removing file {P1}.[nl]", 2, path)
      do ##class(%File).Delete(path)        
    } elseif type = "D" {
      if parentDirectory = "" || (path '[ parentDirectory) {
        set lastParent = parentDirectory
        set parentDirectory = $replace(path, ##class(%File).GetDirectoryPiece(path, $length(path, ..Slash))_..Slash, "")
        if lastParent = "" set lastParent = parentDirectory
      }
      if possiblyDeleted = 1 continue
      do ..Write("Removing directory {P1}.[nl]", 2, path)
      do ##class(%File).RemoveDirectoryTree(path)
    }
  } 
  if length > 0 {
    do ..Write("{P1} extraneous item{P2} removed.[nl]", 1, length, $case(length, 1: " was", : "s were"))
  }
  quit sc
]]></Implementation>
</Method>

<Method name="ExportProjectItems">
<Internal>1</Internal>
<FormalSpec><![CDATA[&exportList:%List=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set s = ##class(%SQL.Statement).%New()
  $$$QuitOnError(s.%PrepareClassQuery("%Studio.Project", "ProjectItemsList"))
  set r = s.%Execute(..ProjectName, 1) 
  while r.%Next(.sc) {
    if $$$ISERR(sc) quit
    set itemName = r.%Get("Name")
    set itemType = r.%Get("Type")
    set sc = $$$ADDSC(sc, ..ExportItem(itemName, itemType, .exportList))
  }
  quit sc
]]></Implementation>
</Method>

<Method name="ExportItem">
<FormalSpec><![CDATA[itemName:%String,type:%String="",&exportList:%List=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ##class(Port.Project.Helper).IsRoutine(itemName) quit ..ExportRoutine(itemName)
  
  set itemType = $case(type, "": ##class(Port.Project.Helper).GetItemExtension(itemName), : type)
  
  if itemType = "CSP" quit ..ExportWebFile(itemName, .exportList)
  if itemType = "PKG" quit ..ExportPackage(itemName, .exportList)
  if itemType = "CLS" {
    set className = itemName
    set classLength = $length(itemName, ".")
    if $piece(itemName, ".", classLength) = "CLS" {
      set className = $extract(itemName, 1, $length(itemName) - 4)
    } 
    quit ..ExportClass(className, .exportList)
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="ExportPackage">
<FormalSpec>packageName:%String,exportList:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $listfind(i%ExportedPackages, packageName) quit $$$OK  
  
  set classList = $System.OBJ.GetPackageList(.classList, packageName)
  set className = ""
  set sc = $$$OK
  for {
    set className = $order(classList(className))
    quit:className=""
    set err = ..ExportClass(className)
    if $$$ISERR(err) {
      if $$$ISOK(sc) set sc = err
      else  set sc = $$$ADDSC(sc, err)
    }
  }
  set $list(exportList, $listlength(exportList) + 1) = "cls/"_packageName
  set $list(i%ExportedPackages, $listlength(i%ExportedPackages) + 1) = packageName
  quit sc
]]></Implementation>
</Method>

<Method name="ExportWebFile">
<FormalSpec><![CDATA[itemName:%String,&exportList:%List=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set name = itemName
  
  if $extract(itemName, 1) = "/" {
    set name = $extract(itemName, 2, $length(itemName))  
  }
  
  if '##class(%Studio.ProjectItem).%ExistsId(..Project.Name_"||"_name_"||CSP") {
    quit $$$OK
  } 
      
  set source = ##class(Port.Project.Helper).CSPToAbsoluteAppPath(name)
  set dest = ..NormalizeOutput(name, .path, .ext)  
  
  $$$QuitOnError(##class(Port.Project.Helper).ImplyDirectoryCreation(path))  
  do ..ExtractPathDependency(source, dest)
  
  if ..Overwrite = 0 && '..IsOutdated(source, dest) {
    quit $$$OK
  }
  
  do ..Write("Exporting {P1} ...", 2, name)
  
  set exported = ##class(%File).CopyFile(source, dest)
  if exported = 0 {
    do ..Write(" failed!", 2)
    quit $$$ERROR($$$GeneralError, "Unable to copy source "_source_" to destination "_dest_".")
  }
  
  do ..Write(" done.[nl]", 2)
  set ..AffectedCount = ..AffectedCount + 1
  
  set $list(exportList, $listlength(exportList) + 1) = dest
  if '..IsBatch do ..AttemptToCallVCSMethod("OnExport", dest)
  
  quit $$$OK
]]></Implementation>
</Method>

<Method name="ExportRoutine">
<FormalSpec>name:%String,exportList:%List=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ##class(Port.Project.Helper).Normalize(name, .extension, .type, .itemName)
  set normalizedName = $piece(name, ".", 1, $length(name, ".") - 1) 
  
  if '##class(%Studio.ProjectItem).%ExistsId(..Project.Name_"||"_itemName_"||"_type) {
    quit $$$OK
  }

  set dest = ..NormalizeOutput(name, .path)  
  do ..ExtractPathDependency(name, dest)
  
  $$$QuitOnError(##class(Port.Project.Helper).ImplyDirectoryCreation(path))
    
  if '##class(%RoutineMgr).Exists(name) { 
    quit $$$ERROR($$$GeneralError, "Unable to export "_name_". Routine does not exist.")
  }
  
  if ..Overwrite = 0 && '..IsOutdated(name, dest) {
    quit $$$OK
  }
  
  do ..Write("[nl]Exporting {P1} ...", 2, itemName)
  
  set file = ##class(%FileCharacterStream).%New()
  set file.Filename = dest
  
  set routine = ##class(%RoutineMgr).%OpenId(name)  
  set sc = file.CopyFrom(routine.Code)
  
  if $$$ISOK(sc) do ..Write(" done.", 2)
  else  do ..Write(" failed!", 2) quit sc
    
  set $list(exportList, $listlength(exportList) + 1) = dest
  
  if '..IsBatch do ..AttemptToCallVCSMethod("OnExport", dest)  
  $$$QuitOnError(file.%Save())
  
  set ..AffectedCount = ..AffectedCount + 1
  quit $$$OK
]]></Implementation>
</Method>

<Method name="IsClassProjectItem">
<FormalSpec>itemName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  
  set exists = ##class(%Studio.ProjectItem).%ExistsId(..ProjectName_"||"_itemName_"||CLS")
  if 'exists {
    set classPartsLength = $length(itemName, ".")
    for i=1:1:classPartsLength - 1 {
      set exists = ##class(%Studio.ProjectItem).%ExistsId(..ProjectName_"||"_$piece(itemName, ".", 1, i)_"||PKG")
      if exists quit      
    }
  }
  quit exists
]]></Implementation>
</Method>

<Method name="ExportClass">
<FormalSpec><![CDATA[itemName:%String,&exportList:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set classLength = $length(itemName, ".")
  set package = $piece(itemName, ".", 1, classLength - 1)
  set isProjectItem = ..IsClassProjectItem(itemName)
  
  if $listfind(..ExportedPackages, package) quit $$$OK
  
  if 'isProjectItem {
    quit $$$OK
  }
  
  set dest = ..NormalizeOutput(itemName_".CLS", .path)
  
  $$$QuitOnError(##class(Port.Project.Helper).ImplyDirectoryCreation(path))  
  do ..ExtractPathDependency(itemName, dest)
  
  if ..Overwrite = 0 && '..IsOutdated(itemName_".CLS", dest) {
    quit $$$OK
  }
  
  do ..Write("[nl]Exporting class {P1} ...", 1, itemName)
  if '##class(%ClassDefinition).%ExistsId(itemName) {
    do ..Write(" failed!", 1)
  } 
  $$$QuitOnError(##class(%Compiler.UDL.TextServices).GetTextAsFile($namespace, itemName, dest))
  do ..Write(" done.", 1)
  
  set ..AffectedCount = ..AffectedCount + 1
  set $list(exportList, $listlength(exportList) + 1) = dest
  
  if '..IsBatch do ..AttemptToCallVCSMethod("OnExport", dest)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="ExtractPathDependency">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>itemName:%String,destPath:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  set type = $$$ucase($piece(destPath, ".", $length(destPath, ".") - 1, $length(destPath, ".") - 1)) 
  set basePath = ..ResolvePathType(type)
  if $find($listbuild("", "/"), $extract(basePath)) {
    set basePath = $extract(basePath, 2, $length(basePath))
  }
    
  set absoluteBasePath = ##class(%File).NormalizeFilename(basePath, ..Slash)
  set dirLength = $length(destPath, ..Slash)
  set dirLengthLimit = dirLength - (dirLength - $length(absoluteBasePath, ..Slash))
  
  // Slices the path for every iteration. Ex: /a/b/c -> /a/b -> /a
  for i=dirLength:-1:dirLengthLimit+1 {
    set dir = $piece(destPath, ..Slash, 1, i)    
    if ..PathDependencies.IsDefined(dir) quit
    do ..PathDependencies.SetAt(itemName, dir)
  }
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Helper">
<Abstract>1</Abstract>
<TimeCreated>64306,34528.510985</TimeCreated>

<Method name="ImplyDirectoryCreation">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set isCreated = 1
  if '##class(%File).DirectoryExists(path)  {
    set isCreated = ##class(%File).CreateDirectoryChain(path)
    if isCreated = 0 {      
      quit $$$ERROR(5001, "Unable to create path: "_##class(%File).NormalizeFilename(path))
    }
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="IsRoutine">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName:%String,onlyCompilables:%Boolean=0</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set extension = ..GetItemExtension(itemName)
  
  
  if extension = "MAC"  || (extension = "INT") ||
    (extension = "MVB") || (extension = "MVI") || 
    (extension = "BAS") {
    quit 1
  }
  
  if 'onlyCompilables {
    quit (extension = "INC" || (extension = "DFI"))
  }  
  quit 0
]]></Implementation>
</Method>

<Method name="GetItemExtension">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName:%String,upperCase:%Boolean=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set ext = $piece(itemName, ".", $length(itemName, "."))
  quit $select(upperCase = 1 : $$$ucase(ext), 1: ext)
]]></Implementation>
</Method>

<Method name="GetItemExtensionFromFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>filePath:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  quit $replace(..GetItemExtension(filePath, 0), ".txt", "")
]]></Implementation>
</Method>

<Method name="CSPToAbsoluteAppPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>cspItem:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set installDirectory = $System.Util.InstallDirectory()
  set cspAppDirectory = $System.CSP.GetDefaultApp($namespace)
  set cspAppDirectory = $extract(cspAppDirectory, 2, $length(cspAppDirectory))
  quit ##class(%File).NormalizeFilename($replace(cspItem, cspAppDirectory, installDirectory_"csp/"_$$$lcase($namespace)))
]]></Implementation>
</Method>

<Method name="FileToClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set divider = $select($$$isWINDOWS : "\", 1: "/")
  set normalizedPath = ##class(%File).NormalizeFilename(path)
  quit $replace($extract(normalizedPath, $find(normalizedPath, divider_"cls")+1, $length(normalizedPath)-8), divider, ".")
]]></Implementation>
</Method>

<Method name="ClassToFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>basePath:%String,className:%String,extension:%String="txt"</FormalSpec>
<Implementation><![CDATA[
  set divider = $select($$$isWINDOWS : "\", 1: "/")
  quit ##class(%File).NormalizeFilename(basePath_"/"_$replace(className, ".", divider)_".cls."_extension)
]]></Implementation>
</Method>

<Method name="Normalize">
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,*extension:%String,*itemType:%String,*itemName:%String</FormalSpec>
<Implementation><![CDATA[
   
  set nameOnly = $piece(name, ".", 1, $length(name, ".") - 1)  
  set routines = $listbuild("MAC", "INT", "INC", "MVB", "MVI", "BAS", "DFI")
  set extension = ..GetItemExtension(name)

  if ..IsRoutine(name) {
    set itemType = extension
    if extension = "INC" || (extension = "BAS") || (extension = "MVI") {
      set itemType = "MAC"
    }
    set itemName = nameOnly_"."_extension  
  } elseif extension = "CLS" {
    set itemName = nameOnly  
    set itemType = extension
  } else {
    set itemName = name
    set itemType = "CSP"
  }
]]></Implementation>
</Method>

<Method name="FileToCSPItem">
<ClassMethod>1</ClassMethod>
<FormalSpec>source:%String,*itemPath:%String,*itemName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set slash = $select($$$isWINDOWS : "\", 1: "/") 
  set installDir = $System.Util.InstallDirectory()
  set webFilePath = $extract(source, $find(source, slash_"web"_slash), *)
  set itemPath = ##class(%File).NormalizeFilename($System.Util.InstallDirectory()_"/csp/"_$namespace_"/"_webFilePath)
  set path = ##class(%File).GetDirectory(itemPath)
  set cspAppPath = $System.CSP.GetDefaultApp($namespace)
  set itemName = $extract(cspAppPath, 2, *)_"/"_$replace(webFilePath, "\", "/")
  quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Importer">
<Super>Port.Project.Base</Super>
<TimeCreated>64306,34528.722609</TimeCreated>

<Property name="IsNewProject">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Property name="CSPPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Backup">
<Type>Port.Project.Backup</Type>
<Private>1</Private>
</Property>

<Property name="BackupDirectory">
<Type>%String</Type>
<Internal>1</Internal>
</Property>

<Property name="SkipBackup">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="CompileList">
<Type>%String</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="ImportList">
<Type>%String</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ItemsList">
<Type>%String</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>inputPath:%String,logLevel:%Integer=2</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ##super(inputPath, logLevel)
  
  set installDirectory = $System.Util.InstallDirectory()
  
  set ..CSPPath = ##class(%File).NormalizeFilename(installDirectory_"csp/"_$$$lcase($namespace))  
  set ..BackupDirectory = ##class(%File).NormalizeFilename(..BasePath_"/__backup__/")
  set ..Backup = ##class(Port.Project.Backup).%New(..BackupDirectory)
  set ..Backup.Logger = ..Logger
  
  set i%CompileList = 0
  set i%ImportList = 0
  set i%ItemsList = 0
  
  if '$isobject(..Project) {
    set ..IsNewProject = 1
    set ..Project = ##class(%Studio.Project).%New()
    set ..Project.Name = ..ProjectName
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="EnqueueAllFromVCS">
<FormalSpec>filter:%String="AMD"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..ResetLists()
  
  set sc = $$$OK
  set ds = ##class(%SQL.Statement).%New()
  
  $$$QuitOnError(ds.%PrepareClassQuery($classname(..VCS), "Diff"))
  set rows = ds.%Execute(..BasePath, ..VCS.#PATHS,,..VCS.GetParameter("commit"))
  
  while rows.%Next(.sc) {
    if $$$ISERR(sc) quit
    set compilable = 0
    set path = rows.%Get("Path") 
    set type = rows.%Get("Type")
    set external = ##class(%File).NormalizeFilename(path, ..BasePath)
    do ..EnqueueItem(external, type)
  }
  quit sc
]]></Implementation>
</Method>

<Method name="EnqueueAll">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..ResetLists()
  
  set sc = $$$OK
  for i = ..IncPath, ..IntPath, ..ClassPath, ..MacPath, ..MviPath, ..MvbPath, ..DfiPath, ..WebPath {
    set sc = ..EnqueueDirectory(i)
    if $$$ISERR(sc) quit
  }
  quit sc
]]></Implementation>
</Method>

<Method name="EnqueueItem">
<FormalSpec>target:%String,diffType:%String=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set enqueued = 0    
  set isWebPath = target [ ..WebPath
  
  if '##class(%File).Exists(target) {
    set enqueued = 0
    quit enqueued
  }
  
  set described = ..Describe(
    target, isWebPath, .sc, .isOutdated,
    .compilable, .internalFileName, .itemName, 
    .itemType, .group, .alias
  ) 
  if described && '$data(i%ItemsList(itemName)) {
    if '..Backup.IsRequired && '..SkipBackup && ((itemType = "CSP") || (itemType = "CSR") && isOutdated) {
      set ..Backup.IsRequired = 1
    }
    set i%ItemsList = $increment(i%ItemsList)
    set i%ItemsList(itemName) = diffType    
    
    if ((diffType = "M") || (diffType = "A")) || isOutdated || ..Overwrite {      
      set i%ImportList = $increment(i%ImportList)
      set i%ImportList(group, itemType, alias) = $listbuild(target, internalFileName)
    }    
    if compilable {
      set i%CompileList = i%CompileList + 1
      set i%CompileList(group, itemName) = ""
    }
    set enqueued = 1
  }
  quit enqueued
]]></Implementation>
</Method>

<Method name="EnqueueDirectory">
<FormalSpec>searchPath:%String,fs:%SQL.Statement=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if '..IsBatch && '$isobject(fs) {
    do ..ResetLists()
  }
  
  if '$isobject(fs) {
    set fs = ##class(%SQL.Statement).%New()
    $$$QuitOnError(fs.%PrepareClassQuery("%File", "FileSet"))
  }
  
  set sc = $$$OK
  set rows = fs.%Execute(searchPath)  
  
  while rows.%Next(.sc) {
    if $$$ISERR(sc) quit 
    set compilable = 0
    set type = rows.%Get("Type")
    set external = rows.%Get("Name")
    if type = "F" { do ..EnqueueItem(external) }
    elseif type = "D" {
      set targetDir = $piece(external, ..Slash, $length(external, ..Slash))
      if '(targetDir?1".".AN) {
        set sc = ..EnqueueDirectory(external, fs)
        if $$$ISERR(sc) quit
      }
    }   
  }
  quit sc
]]></Implementation>
</Method>

<Method name="GetTypePriority">
<FormalSpec>type:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  if type = ".INC" quit 1
  if type = ".INT" quit 2
  if type = ".CLS" quit 3
  if type = ".MAC" quit 4
  if type = ".MVI" quit 5
  if type = ".MVB" quit 6
  if type = ".BAS" quit 7
  if type = ".DFI" quit 8
  if type = ".CSR" quit 9
  quit 10
]]></Implementation>
</Method>

<Method name="Describe">
<Internal>1</Internal>
<FormalSpec>origin:%String,isWebPath:%Boolean=0,sc:%Status,*isOutdated:%Boolean=0,*isCompilationCandidate:%Boolean=0,*itemDestination:%String,*itemName:%String,*itemType:%String,*priority:%String,*alias:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  set described = 0 
  set extension = ..GetFileExtension(origin, isWebPath)
  
  if '(extension?1".".AN) quit described
  if extension = "" quit described
    
  set priority = ..GetTypePriority(extension)
  
  if extension = ".CLS" {
    set itemType = "CLS"
    set itemDestination = ##class(Port.Project.Helper).FileToClass(origin)       
    set itemName = itemDestination_extension
    set alias = itemDestination
    set described = 1
  } elseif $listfind($$$RoutineExtensions, extension) {
    set itemType = $piece(extension, ".", 2)
    set itemDestination = $extract(##class(%File).GetFilename(origin), 1, *-8)_extension
    set itemName = itemDestination
    set alias = itemName
    set described = 1
  } else {
    if extension = ".CSR" set itemType = "CSR"
    else  set itemType = "CSP"
    set sc = ##class(Port.Project.Helper).FileToCSPItem(origin, .itemDestination, .itemName)
    set alias = itemName
    set described = 1
  }
  
  if '..Overwrite {
    set isOutdated = ..IsOutdated(itemName, origin, 1, .isCompilationCandidate)
  } else {
    set isCompilationCandidate = 1
    set isOutdated = 1
  }
  quit described
]]></Implementation>
</Method>

<Method name="ImportList">
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  
  for i=1:1:10 {
   set sc = ..ImportType(i)
   if $$$ISERR(sc) {
    set typeSC = $$$ERROR($$$GeneralError, "There were errors while importing "_$listget($$$ImportTypeDescriptions, i)_".")
    set typeSC = $$$EMBEDSC(typeSC, sc)
    set sc = typeSC 
   }
  }  
  quit sc
]]></Implementation>
</Method>

<Method name="ImportType">
<Internal>1</Internal>
<FormalSpec>group:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  if $data(i%ImportList(group)) quit sc  
  
  set partialMessage = $listget($$$ImportTypeDescriptions, group)
  do ..WriteExclusive(1, "Importing {P1} ... ", partialMessage)
  set itemName = ""
  for {
    quit:'$data(i%ImportList(group))
    set itemType = $listget($$$ImportTypes, group, "CSP")
    set itemName = $order(i%ImportList(group, itemType, itemName), 1, paths)
    quit:itemName=""
    
    set origin = $listget(paths, 1)
    set destination = $listget(paths, 2)
    set fileType = itemType    
    
    do ..Write("Importing {P1} ", 2, $case(fileType,
      "CLS": "class "_itemName, 
      "MAC": "macro routine "_itemName, 
      "INT": "intermediate routine "_itemName, 
      "INC": "include routine "_itemName,
      "BAS": "Basic routine "_itemName,
      "MVB": "MV Basic routine "_itemName,
      "MVI": "MV Intermediate routine "_itemName,
      "DFI": "DFI XML "_itemName, :
      "file to "_destination)_" ...")
    set sc = $$$ADDSC(sc, ..ImportFromExternalSource(itemName, origin,  fileType, destination))
    if $$$ISERR(sc)  do ..Write("failed![nl]", 2) continue
    else  do ..Write("done.[nl]", 2)
  }
  do ..WriteExclusive(1, "done.[nl]")
  quit sc
]]></Implementation>
</Method>

<Method name="ImportPartial">
<FormalSpec>target:%String,importedList:%String=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  #define NormalizePath(%path)  ##class(%File).NormalizeFilename(%path)
  set sc = $$$OK
  
  set resolvedTarget = ##class(%File).NormalizeFilename(target, ..BasePath)
  
  if (resolvedTarget = ..BasePath) {
    quit $$$ERROR($$$GeneralError, "Ambiguous TARGET and BASEPATH if you wish to import the project, use the method Import instead.")
  }
  
  if '(resolvedTarget [ ..ClassPath || (resolvedTarget [ ..IncPath) ||
      (resolvedTarget [ ..IncPath)  || (resolvedTarget [ ..MacPath) ||
      (resolvedTarget [ ..WebPath)) {    
    quit $$$ERROR($$$GeneralError, "Action supressed: attempted to import files outside the project scope.")
  }    
  
  if ##class(%File).DirectoryExists(resolvedTarget) {
    do ..Write("[nl]Enqueuing directory to be imported ...", 1)   
    set sc = ..EnqueueDirectory(resolvedTarget)
  } elseif ##class(%File).Exists(resolvedTarget) {
    do ..Write("[nl]Enqueuing item to be imported ...", 1)
    set sc = ..EnqueueItem(resolvedTarget)
  } else {
    do ..Write("[nl]Nothing to import.", 1)
    quit sc
  }
  
  if sc {
    do ..Write(" done.[nl]")
    set sc = ..Import()
    if $$$ISOK(sc) {
      set importedList = i%ImportList
      merge importedList = i%ImportList
    }
  } else {
    do ..Write(" failed.[nl]")
  }  
  quit sc
]]></Implementation>
</Method>

<Method name="Import">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set onlyPopulateProject = 0
  set ..AffectedCount = 0
  set hasVCS = ..IsVCSEnabled()
      
  tstart
  
  try {
    if ..IsBatch {
      do ..Write("[nl][nl]Importing project {P1} ...[nl]", 1, ..Project.Name)            
      if 'hasVCS {
        do ..Write("Enqueuing items to import ... ", 1)
        $$$ThrowOnError(..EnqueueAll())
      } else {
        do ..Write("A version control system has been detected: {P1}.[nl]", 1, ..VCS.#NAME)
        do ..Write("Using {P1} diff based on commit {P2}.[nl]", 1, ..VCS.#NAME, ..VCS.GetParameter("commit"))
        do ..Write("Enqueuing items to import ... ", 1)
        $$$ThrowOnError(..EnqueueAllFromVCS())
      } 
    }
      
    if i%ImportList > 0 {
      do ..Write("[nl]Found {P1} item{P2} to be imported.[nl]", 1, i%ImportList, $select(i%ImportList > 1 : "s", 1: ""))
      merge list = i%ImportList
      if '..SkipBackup $$$ThrowOnError(..Backup.Create(.list))
      $$$ThrowOnError(..ImportList())
    } else {
      do ..Write("[nl]no pending items were found inside the repository.", 1)
      do ..Write("[nl]Current repository might be empty or up-to-date.", 1)
    }
    
    if i%CompileList {
      set compilationSC = ..CompileList()
      if $$$ISERR(compilationSC) {
        do ..Write("[nl]WARNING: There were compilations errors.[nl]")
        do $System.OBJ.DisplayError(compilationSC)
      }
    }
    
    if ..IsNewProject {
      do ..Write("Project doesn't exists. A new project will be created with the name {P1}.[nl]", 1, ..Project.Name)
    }
    
    if i%ImportList || (hasVCS && (i%ItemsList > 0)) {
      do ..Write("[nl][nl]Synchronizing {P1} ...", 1, ..Project.Name)
      $$$ThrowOnError(..SynchronizeProject(.added, .removed))
      do ..Write(" done.[nl]")
      do ..Write("[nl]Project {P1} has been saved with {P2} items (+ {P2} - {P3}).[nl]", 1, ..Project.Name, ..Project.Items.Count(), added, removed)
    }
    
    set ..AffectedCount = i%ImportList    
    
    if ..Backup.IsRequired && '..SkipBackup {
      // If anything is ok until here, then delete the backup.
      do ..Write("[nl]Removing backup directory ...")
      set isRemoved = ##class(%File).RemoveDirectoryTree(..BackupDirectory)
      if isRemoved { 
        do ..Write(" done.[nl]")
        set ..Backup.IsRequired = 0
      } else  {
        set backupErrorMessage = "Unable to remove the directory "_..BackupDirectory
        do ..Write(" failed! Unable to clear directory.", 1)
        $$$ThrowOnError($$$ERROR(5001, backupErrorMessage))
      }
    }
    tcommit     
  } catch ex {
    set sc = ex.AsStatus()
    do ..Write("[nl][nl]FATAL: There were errors preventing the project to be imported:[nl]", 1)
    do $System.OBJ.DisplayError(sc)
    do ..Write("[nl][nl]The importer will now rollback all changes.[nl]", 1)
    do ..Write("PLEASE DO NOT INTERRUPT THIS PROCESS OR INTEGRITY WILL BE LOST![nl]", 1)
    do ..Write("Rolling back to the last working snapshot ...", 1)

    // Rolls back the database to recover last working Caché files.
    trollback
    do ..Write(" done.[nl]")
    
    if ..Backup.IsRequired {
      do ..Write("Reverting {P1} using backup version ...", 1, $System.CSP.GetDefaultApp($namespace))
      set isCopied = ##class(%File).CopyDir(..BackupDirectory, ..CSPPath, 1)
      if isCopied { do ..Write(" done.[nl]") }
      else {
        do ..Write(" failed![nl]")
        do ..Write("Failed to restore the pending backup due to a file system error, backup will not be removed.")
      }     
    
      if 'isCopied {
        set sc = $$$ADDSC(sc, $$$ERROR(5001, "Failed to restore the pending backup due to a file system error."))
      }
    }
  }
  quit sc
]]></Implementation>
</Method>

<Method name="CompileList">
<FormalSpec>qspec:%String="/expand/nodisplay/checkuptodate/multicompile=1/lock=0"</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set (sc, allTypesSC) = $$$OK
  
  if i%CompileList '> 0 {
    do ..Write("[nl][nl]Compilation skipped: No items to compile.", 1)
    quit $$$OK
  }
  
  do ..Write("[nl][nl]Found {P1} item{P2} to compile ...", 1, i%CompileList, $case(i%CompileList, 1: "", : "s"))
  
  set typeMessages(2)   = "intermediate routines"
  set typeMessages(3)   = "classes"
  set typeMessages(4)   = "macro routines"
  set typeMessages(5)   = "MV Intermediate routines"
  set typeMessages(6)   = "MV Basic routines"
  set typeMessages(7)   = "Basic routines"
  set typeMessages(8)   = "DFI XML Routines"
  set typeMessages(9)   = "CSP Rules"
  set typeMessages(10)  = "CSP files"
  
  for i=2,3,4,5,6,7,9,10 {
    kill list
    set typeSC = $$$OK
    merge list = i%CompileList(i)    
    if $data(list) {
      do ..Write("[nl]Compiling {P1} ... ", 1, typeMessages(i))
      set typeSC = $System.OBJ.CompileList(.list, qspec)
    }    
    if $$$ISERR(typeSC) {      
      set allTypesSC = $$$ADDSC(allTypesSC, $$$ERROR($$$GeneralError, "Failed to compile all "_typeMessages(i)_"."))
      set allTypesSC = $$$EMBEDSC(allTypesSC, typeSC)
    }
  }
  if $$$ISERR(allTypesSC) {
    do ..Write("[nl]", 0)
    set sc = $$$ERROR($$$GeneralError, "Failed to compile all items.")
    set sc = $$$EMBEDSC(sc, allTypesSC)
  }
  quit sc
]]></Implementation>
</Method>

<Method name="ImportFromExternalSource">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName:%String,origin:%String,fileType:%String,destination:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK 
  
  if (fileType = "CLS") {      
    $$$QuitOnError(##class(%Compiler.UDL.TextServices).SetTextFromFile($namespace, itemName, origin))
  } elseif ##class(Port.Project.Helper).IsRoutine(itemName) {
    set routine = ""
    set fs = ##class(%FileCharacterStream).%New()
    set fs.Filename = origin
    
    if ##class(%RoutineMgr).Exists(itemName) {      
      set routine = ##class(%RoutineMgr).%OpenId(itemName)              
    } else {
      set routine = ##class(%RoutineMgr).%New(itemName)
    }
    
    set code = routine.Code
    do code.Clear()
    
    $$$QuitOnError(code.CopyFrom(fs))
    set sc = code.Save()
  } else {
    set destinationPath = ##class(%File).GetDirectory(destination)
    $$$QuitOnError(##class(Port.Project.Helper).ImplyDirectoryCreation(destinationPath))    
    set isCopied = ##class(%File).CopyFile(origin, destination, 1)
    if isCopied = 0 {
      set sc = $$$ERROR($$$GeneralError, "Unable to copy "_origin_" to destination.")
    }
  }
  quit sc
]]></Implementation>
</Method>

<Method name="GetFileExtension">
<Internal>1</Internal>
<FormalSpec>path:%String,isWebPath:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if $piece(path, ..Slash, *)?1"."3A quit ""
  if isWebPath set sliceSize = 0
  else  set sliceSize = 1
  // -1 to ignore last piece (.txt) when not inside web path.
  quit "."_$zconvert($piece(path, ".", *-sliceSize), "U")
]]></Implementation>
</Method>

<Method name="SynchronizeProject">
<FormalSpec>*addedCount:%String=0,*removedCount:%String=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set (sc, scc) = $$$OK
  set itemName = ""
    
  #dim item As %Studio.Project
  
  if ..IsBatch {
    // Removes all project items that can't be found in the repository.
    for i=1:1:..Project.Items.Count() {
      set item = ..Project.Items.GetAt(i)
      set destination = ""
      set (candidateToRemove, removed) = 0
      if $isobject(item) {
        set name = item.Name
        if item.Type = "CLS" set name = name_".CLS"
        if item.Type = "PKG" {
          set name = name_".PKG"
          set packageName = item.Name_".PKG"
          do $System.OBJ.GetPackageList(.classes, item.Name)
          set className = ""
          for {
            set className = $order(classes(className))
            quit:className=""
            set className = className_".CLS"
            set destination = ..NormalizeOutput(className)
            if '##class(%File).Exists(destination) {
              if $data(items(className)) {
                set removedCount = removedCount + 1
                set i%ItemsList = i%ItemsList - 1
                kill i%ItemsList(className)
              }
            } elseif '$data(items(className)) {
              // While the package itself might not be a project item, if the class
              // is found inside the repository, the list must be updated to include it.            
              set i%ItemsList = i%ItemsList + 1
              set i%ItemsList(className) = ""
            }
          }
          // Notice that the package is always removed.
          set removed = $$$ISOK(..Project.RemoveItem(name))
        } else {
          set destination = ..NormalizeOutput(name)
          if '##class(%File).Exists(destination) {
            set removed = $$$ISOK(..Project.RemoveItem(name))
          }
        }
        if removed && $data(items(name)) {
          kill i%ItemsList(name)
          set i%ItemsList = i%ItemsList - 1
          set removedCount = removedCount + 1           
        }     
      }
    }
  }
  
  // Does the opposite, adds new items to the project.
  for {
    set itemName = $order(i%ItemsList(itemName), 1, operation)
    quit:itemName=""
    continue:operation="D"
    
    set name = itemName
    
    do ..Project.NormalizeName(.name, .type)
    set id = ..ProjectName_"||"_name_"||"_type
    set newItem = (..Project.Items.FindObjectId(id) = "")
    
    set sc = $$$ADDSC(sc, ..Project.AddItem(itemName))
    if $$$ISOK(sc) && newItem set addedCount = addedCount + 1
  }
  set ssc = ..Project.%Save()
  set scc = $$$EMBEDSC(scc, sc)
  quit scc
]]></Implementation>
</Method>

<Method name="ResetLists">
<Implementation><![CDATA[
  kill i%CompileList, i%ImportList, i%ItemsList
  set (i%CompileList, i%ImportList, i%ItemsList) = 0
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Manager">
<IncludeCode>portutils</IncludeCode>
<TimeCreated>64306,34528.811674</TimeCreated>

<Method name="AssertUtilityCreation">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String,path:%String,logLevel:%String,sc:%Status</FormalSpec>
<Private>1</Private>
<ReturnType>Port.Project.Base</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set utility = ""  
  set utilityTypes("E") = "Port.Project.Exporter"
  set utilityTypes("I") = "Port.Project.Importer"
  set utilityTypes("X") = "Port.Project.XMLExporter"
  
  try {
    set utility = $classmethod(utilityTypes(type), "%New", path, logLevel)
    quit
  } catch ex {
    set sc = ex.AsStatus()
  }
  quit utility
]]></Implementation>
</Method>

<Method name="Export">
<ClassMethod>1</ClassMethod>
<FormalSpec>outputPath:%String,logLevel:%Boolean=2,force:%Boolean=0,vcs:Port.SourceControl.Extension.VCS=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set exporter = ..AssertUtilityCreation("E", outputPath, logLevel, .sc)
  $$$QuitOnError(sc)
  set exporter.VCS = vcs
  set exporter.Overwrite = force  
  $$$QuitOnError(exporter.Export())
  set projectName = exporter.GetProjectName()
  if exporter.AffectedCount > 0 {
    $$$QuitOnError(##class(Port.SourceControl.Log).LogChange(projectName, projectName_".PRJ"))
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="ExportToXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>outputPath:%String,justProject:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set exporter = ..AssertUtilityCreation("X", outputPath, 0, .sc)
  $$$QuitOnError(sc)  
  quit exporter.ExportToXML(justProject)
]]></Implementation>
</Method>

<Method name="Import">
<ClassMethod>1</ClassMethod>
<FormalSpec>inputPath:%String,logLevel:%Boolean=2,skipBackup:%Boolean=0,overwrite:%Boolean=0,vcs:Port.SourceControl.Extension.VCS=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set importer = ..AssertUtilityCreation("I", inputPath, logLevel, .sc)
  $$$QuitOnError(sc)
  set importer.SkipBackup = skipBackup
  set importer.VCS = vcs
  set importer.IsBatch = 1
  set importer.Overwrite = overwrite
  set projectName = importer.GetProjectName()
  $$$QuitOnError(importer.Import())
  if importer.AffectedCount > 0 {
    $$$QuitOnError(##class(Port.SourceControl.Log).LogChange(projectName, projectName_".PRJ"))
  }
  quit sc
]]></Implementation>
</Method>

<Method name="ImportPartial">
<ClassMethod>1</ClassMethod>
<FormalSpec>basePath:%String,target,logLevel:%Boolean=2,skipBackup:%Boolean=0,overwrite:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set importer = ..AssertUtilityCreation("I", basePath, logLevel, .sc)
  $$$QuitOnError(sc)
  
  set importer.LogLevel = logLevel
  set importer.SkipBackup = skipBackup
  set importer.Overwrite = 1  
     
  $$$QuitOnError(importer.ImportPartial(target, .importedList))
  do ..LogFromImportList(importer.GetProjectName(), .importedList)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="RemoveInvalidItems">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String=^||%Studio.Project</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set project = ##class(%Studio.Project).%OpenId(projectName)
  $$$QuitOnError(project.Check())
  $$$QuitOnError(project.%Save()) 
  quit $$$OK
]]></Implementation>
</Method>

<Method name="RemoveItemsFromCategory">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,type:%String,*items:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set project = ##class(%Studio.Project).%OpenId(projectName)
  set s = ##class(%SQL.Statement).%New()
  $$$QuitOnError(s.%PrepareClassQuery("%Studio.Project", "ProjectItemsList"))
  set r = s.%Execute(projectName)
  
  while r.%Next() {
    set itemType = r.%Get("Type")
    set name = r.%Get("Name")
    if itemType = type {
      set items(name) = ""
      set sc = project.RemoveItem(name, itemType)
      if $$$ISERR(sc) quit
    }
  }
  $$$QuitOnError(project.%Save())
  quit sc
]]></Implementation>
</Method>

<Method name="ExportTestSuiteToXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>outputPath:%String,vcs:Port.SourceControl.Extension.VCS=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set testPath = ##class(Port.SourceControl.Config).GetTestPath()
  set exporter = ..AssertUtilityCreation("X", .outputPath, 0, .sc)
  $$$QuitOnError(sc)
  quit exporter.ExportTests(outputPath_"/"_testPath)
]]></Implementation>
</Method>

<Method name="LogFromImportList">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[projectName:%String,&importList:%String]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  if 'importList quit
  
  for i=1:1:10 {
    do LoopThroughType(projectName, importList, i)
  }  
  
LoopThroughType(projectName, importedList, group)
  set itemName = "" 
  
  for {
    set itemName = $order(importList(group, $listget($$$ImportTypes, group), itemName))
    quit:itemName=""
    
    if group = 2 set itemName = itemName_".CLS"   
    do ##class(Port.SourceControl.Log).LogChange(projectName, itemName)
  }
  quit 1
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.XMLExporter">
<Super>Port.Project.Base</Super>
<TimeCreated>64306,34528.900364</TimeCreated>

<Method name="ExportToXML">
<FormalSpec>justProject:%Boolean=0,qspec:%String="/diffexport=1/nodisplay",charset:%String="UTF8",*errorlog:%Status=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set destination = ##class(%File).NormalizeFilename(..BasePath_"/"_..ProjectName_".xml")  
  do ..Write("[nl]Exporting project {P1} to XML ...", 0, ..GetProjectName())
  $$$QuitOnError(..Project.Export(destination, qspec, justProject, errorlog, charset))
  do ..Write("[nl]Project exported to {P1}", 0, destination)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="ExportTests">
<FormalSpec><![CDATA[path:%String,qspec:%String="/diffexport=1/nodisplay",&tests:%String="",&errors=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  set sc = $$$OK
  set exported = 0
  
  set absoluteBasePath = ##class(%File).NormalizeFilename(path)
  $$$QuitOnError(##class(Port.Project.Helper).ImplyDirectoryCreation(absoluteBasePath))
  
  set s = ##class(%SQL.Statement).%New()
  $$$QuitOnError(s.%PrepareClassQuery("%Studio.Project", "ProjectItemsList"))
  set r = s.%Execute(..Project.Name)
  while r.%Next(.sc) {
    if $$$ISERR(sc) quit
    set type = r.%Get("Type")
    if type = "CLS" {     
      set class = r.%Get("Name")      
      if 'exported set exported = ..ExportTest(absoluteBasePath, class, .esc, qspec)
      else  do ..ExportTest(absoluteBasePath, class, .esc)          
      set sc = $$$ADDSC(sc, esc)
    }
  } 
  if 'exported {
    set sc = $$$ERROR(5001, "No test suites were found for this project.")
  }
  quit sc
]]></Implementation>
</Method>

<Method name="ExportTest">
<FormalSpec>absoluteBasePath:%String,className:%String,sc:%Status=$$$OK,qspec="/diffexport=1/nodisplay"</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set exported  = 0
  
  if '..IsUnitTestClass(className) quit exported  
  
  set test = ..ResolveTestLocation(absoluteBasePath, className)
  
  if $listvalid(test) && (test '= "") {
    set className = $listget(test, 1)
    set classPath = $listget(test, 2)
    do ..Logger.Log("Exporting test class {P1} ... ", 1, $replace(className, ".CLS", ""))
    set sc = $$$ADDSC(sc, $System.OBJ.Export(className, classPath,qspec,, "UTF-8"))
    write " done."
    set exported = 1
  }
  quit exported
]]></Implementation>
</Method>

<Method name="ResolveTestLocation">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>absoluteBasePath:%String,className:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set test = $listbuild(className_".CLS", ##class(Port.Project.Common).ClassToFile(absoluteBasePath, className, "xml"))     
  quit test
]]></Implementation>
</Method>

<Method name="IsUnitTestClass">
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  quit (
    ##class(%Library.ClassDefinition).%ExistsId(className) &&
    (##class(%Dictionary.ClassDefinition).%OpenId(className).Super [ "Port.UnitTest.TestCase")
  )
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.Config">
<Super>%SYSTEM.Help</Super>
<TimeCreated>64306,34528.990495</TimeCreated>

<Method name="SetLogLevel">
<Description>
Sets the log level used to display the info. Ranging from 1 to 3, greater is more detailed.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>logLevel:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if '$isvalidnum(logLevel) {
    quit $$$ERROR($$$GeneralError, "Log level must be a number between 0 and 2.")
  }
  if logLevel > 0 && (logLevel < 3) {
    set ^Port.SourceControl.Settings("general.logLevel") = logLevel
    quit $$$OK
  }
  quit $$$ERROR($$$GeneralError, "Log level out of range.")
]]></Implementation>
</Method>

<Method name="GetLogLevel">
<Description>
Gets the current configured log level.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit $get(^Port.SourceControl.Settings("general.logLevel"), 0)
]]></Implementation>
</Method>

<Method name="SetExportPath">
<Description>
Sets the path where the files are to be exported. Supports template.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>newExportPath:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  set ^Port.SourceControl.Settings("source.path") = $get(newExportPath, "/CacheProjects/{NAMESPACE}/{PROJECT}")
]]></Implementation>
</Method>

<Method name="GetExportPath">
<Description>
Gets the resolved export path. Pass 1 to excludeProject to return the project's parent directory.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>excludeProject:%Boolean=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  quit ..rewritePlaceHolders($get(^Port.SourceControl.Settings("source.path")), excludeProject)
]]></Implementation>
</Method>

<Method name="SetTestPath">
<Description>
Sets the path which the source control should export and look up for tests on XML format.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>newPath:%String</FormalSpec>
<Implementation><![CDATA[
  
  set ^Port.SourceControl.Settings("test.path") = $get(newPath, "__tests__/cls")
]]></Implementation>
</Method>

<Method name="GetTestPath">
<Description>
Gets the resolved test path.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  quit ..rewritePlaceHolders($get(^Port.SourceControl.Settings("test.path")))
]]></Implementation>
</Method>

<Method name="EnableTestOnDemand">
<Description>
Informs the source control to run associated test class when the source is compiled.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[  set ^Port.SourceControl.Settings("test.ondemand") = 1
]]></Implementation>
</Method>

<Method name="DisableTestOnDemand">
<Description>
Disables the test class association.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[  set ^Port.SourceControl.Settings("test.ondemand") = 0
]]></Implementation>
</Method>

<Method name="IsTestOnDemandEnabled">
<Description>
Returns 1 if association is enabled, 0 if not.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  quit ($get(^Port.SourceControl.Settings("test.ondemand")) = 1)
]]></Implementation>
</Method>

<Method name="EnableExportOnlyAssertedClass">
<Description>
Forces the source control to skip class exportation if source is not covered by it's test class.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[  set ^Port.SourceControl.Settings("test.exportAsserted") = 1
]]></Implementation>
</Method>

<Method name="DisableExportOnlyAssertedClass">
<Description>
Disable test class constraint, allowing the source to be exported regardless of having a test class.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[  set ^Port.SourceControl.Settings("test.exportAsserted") = 0
]]></Implementation>
</Method>

<Method name="IsClassAssertionRequired">
<Description>
Returns 1 if constraint is enabled, 0 if not.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ($get(^Port.SourceControl.Settings("test.exportAsserted")) = 1)
]]></Implementation>
</Method>

<Method name="SetTestClassPrefix">
<Description>
Sets the prefix used to associate the source with it's test class.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>newPrefix:%String</FormalSpec>
<Implementation><![CDATA[  set ^Port.SourceControl.Settings("test.prefix") = newPrefix
]]></Implementation>
</Method>

<Method name="GetTestClassPrefix">
<Description>
Gets the association prefix.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  quit $get(^Port.SourceControl.Settings("test.prefix"))
]]></Implementation>
</Method>

<Method name="SetVCSCommand">
<Description>
Sets a VCS (version control system) command. Supports template.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>command:%String,args:%Status=""</FormalSpec>
<Implementation><![CDATA[  set ^Port.SourceControl.Settings("vcs.command", command) = args
]]></Implementation>
</Method>

<Method name="GetVCSCommand">
<Description>
Gets the resolved VCS command.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>command:%String,args...:%String</FormalSpec>
<Implementation><![CDATA[  quit ..rewritePlaceHolders($get(^Port.SourceControl.Settings("vcs.command", command)), 0, args...)
]]></Implementation>
</Method>

<Method name="SetVCSPath">
<Description>
Sets the VCS executable path. Supports template.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>vcsPath:%String</FormalSpec>
<Implementation><![CDATA[  set ^Port.SourceControl.Settings("vcs.path") = vcsPath
]]></Implementation>
</Method>

<Method name="GetVCSPath">
<Description>
Gets the resolved VCS executable path.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>fullFilePath:%String</FormalSpec>
<Implementation><![CDATA[  quit ..rewritePlaceHolders($get(^Port.SourceControl.Settings("vcs.path")))
]]></Implementation>
</Method>

<Method name="RegisterVCSHandler">
<Description>
Registers a VCS extension to be used with the source control hook.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>vcs:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  set ^Port.SourceControl.Settings("vcs.name") = vcs
]]></Implementation>
</Method>

<Method name="GetVCSHandlerName">
<Description>
Gets the extension class name.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  quit $get(^Port.SourceControl.Settings("vcs.name"))
]]></Implementation>
</Method>

<Method name="EnableVCS">
<Description>
Enables the VCS extension.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ..GetVCSHandlerName() = "" quit $$$ERROR($$$CacheError, "Unable to change VCS state: Missing VCS handler.")
  set ^Port.SourceControl.Settings("vcs.enabled") = 1
  quit $$$OK
]]></Implementation>
</Method>

<Method name="DisableVCS">
<Description>
Disables the VCS extension.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ..GetVCSHandlerName() = "" {
    quit $$$ERROR($$$CacheError, "Unable to change VCS state: Missing VCS handler.")
  }
  set ^Port.SourceControl.Settings("vcs.enabled") = 0
  quit $$$OK
]]></Implementation>
</Method>

<Method name="IsVCSEnabled">
<Description>
Returns 1 if VCS is enabled, 0 if not.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit ($get(^Port.SourceControl.Settings("vcs.enabled"), 0) && (..GetVCSHandlerName() '= ""))
]]></Implementation>
</Method>

<Method name="rewritePlaceHolders">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>basePath:%String,excludeProject:%Boolean=0,params...:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if '$data(params) set params = ""
  set translatedPath = basePath 
  #define RewriteIfPathContains(%expression, %replacement) set translatedPath = $select(translatedPath [ %expression : $replace(translatedPath, %expression, %replacement), 1: translatedPath) 
  
  set installDirectory = $System.Util.InstallDirectory()
  set installDirectory = $extract(installDirectory, 1, $length(installDirectory) - 1)
  $$$RewriteIfPathContains("{NAMESPACE}", $namespace)
  $$$RewriteIfPathContains("{INSTALLDIR}", installDirectory)
  $$$RewriteIfPathContains("{USERNAME}", $username) 
  $$$RewriteIfPathContains("{EXPORTPATH}", ..GetExportPath())
  $$$RewriteIfPathContains("{FULLEXPORTPATH}", ##class(%File).NormalizeFilename(..GetExportPath())) 
  $$$RewriteIfPathContains("{VCS}", ..GetVCSPath())
  $$$RewriteIfPathContains("{SLASH}", $select($$$isWINDOWS: "\", 1: "/"))
  if 'excludeProject $$$RewriteIfPathContains("{PROJECT}", $get(^||%Studio.Project))
  if params {
    for i=1:1:params $$$RewriteIfPathContains("{P"_i_"}", params(i))
  }
  quit translatedPath
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.Extension.Git">
<Super>Port.SourceControl.Extension.VCS</Super>
<TimeCreated>64306,34529.090076</TimeCreated>

<Parameter name="NAME">
<Default>Git</Default>
</Parameter>

<Parameter name="PATHS">
<Default>cls inc int mac web</Default>
</Parameter>

<Method name="%OnNew">
<FormalSpec>repositoryPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  do ##super(repositoryPath)  
  
  if '##class(%File).DirectoryExists(repositoryPath_"/.git") {
    quit $$$ERROR("Directory is not a git repository.")
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="Install">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set input = ""
  set validated = 0 
  write !!, "This setup will help you to configure a git integration."
  write !,  "Please fill out fields when asked:", !
  
  // git-diff tool configuration
  set defaults(2) = "{VCS} --work-tree={P1} --git-dir={P1}{SLASH}.git diff --name-status --diff-filter={P2} {P3} -- {P4} 2> ""{P5}"" > ""{P6}"""
  set defaults(3) = "{VCS} --work-tree={P1} --git-dir={P1}{SLASH}.git add {P2}"
  set defaults(4) = "{VCS} --work-tree={P1} --git-dir={P1}{SLASH}.git log --pretty=format:""%H||%an||%ae||%ad||at"" --date=relative 2> ""{P2}"" > ""{P3}"""
    
  while 1 {   
    if input = -1 write !, "Aborted." quit     
    if '$get(validated(1), 0) {
      set input(1) = ""
      write !, "git.exe full path: "
      read input(1)
      
      if input(1) = -1 set input = 1
      
      set validated(1) = (##class(%File).Exists(input(1)) && (##class(%File).GetFilename(input(1)) = "git.exe"))
      if 'validated(1) {
        write !, "Invalid path, you must specify the path for your git.exe."
        continue
      }
    }
    
    if '$get(validated(2), 0) {
      set input(2) = ""
      write !, "diff command (or empty to use default): "
      read input(2)
      
      if input(2) = -1 set input = 1
      if input(2) = "" set input(2) = defaults(2)
      
      set validated(2) = 1
    }
    
    if '$get(validated(3), 0) {
      set input(3) = ""
      write !, "add command (or empty to use default):"
      read input(3)  
      
      if input(3) = -1 set input = 1
      if input(3) = "" set input(3) = defaults(3)
      
      set validated(3) = 1
    }
    
    if validated(1) && validated(2) && validated(3) quit
  }
  
  do ##class(Port.SourceControl.Config).SetVCSPath(input(1))
  do ##class(Port.SourceControl.Config).SetVCSCommand("diff", input(2))
  do ##class(Port.SourceControl.Config).SetVCSCommand("add", input(3))
  do ##class(Port.SourceControl.Config).SetVCSCommand("log", defaults(4))
  do ##class(Port.SourceControl.Config).RegisterVCSHandler($classname($this))
  do ##class(Port.SourceControl.Config).EnableVCS()
  write !!, "Done. Git is now integrated with the source control hook."
  quit $$$OK
]]></Implementation>
</Method>

<Method name="add">
<FormalSpec>file:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set params = 2
  set params(1) = ..RepositoryPath
  set params(2) = file
  set command = ##class(Port.SourceControl.Config).GetVCSCommand("add", params...)
  
  do $zf(-1, command)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="diff">
<FormalSpec>paths:%String=".",filter:%String="AMD",commit:%String="HEAD",consoleOutput:%Stream.GlobalCharacter,consoleError:%Stream.GlobalCharacter</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
  set sc = $$$OK
  set params = 6
  set params(1) = ..RepositoryPath
  set params(2) = filter    
  set params(3) = commit  
  
  set params(4) = paths
  set params(5) = ..ErrorFilePath
  set params(6) = ..OutputFilePath
    
  set command = ##class(Port.SourceControl.Config).GetVCSCommand("diff", params...)
  set ^mtempPort = command 
  
  do $zf(-1, command)
  
  set outputFile = ##class(%FileCharacterStream).%New()
  set errorFile = ##class(%FileCharacterStream).%New()  
  
  set outputFile.Filename = ..OutputFilePath
  set errorFile.Filename  = ..ErrorFilePath
  
  set consoleOutput = ##class(%Stream.GlobalCharacter).%New()
  set consoleError = ##class(%Stream.GlobalCharacter).%New()
  
  $$$QuitOnError(consoleOutput.CopyFrom(outputFile))
  $$$QuitOnError(consoleError.CopyFrom(errorFile))
  
  set consoleOutput.LineTerminator  = $char(10)
  set consoleError.LineTerminator   = $char(10)
  
  do outputFile.Clear()
  do errorFile.Clear()
    
  if consoleOutput.Size = 0 && (consoleError.Size > 0) {
    do consoleError.Rewind()
    set sc = $$$ERROR(5001, "Unable to diff targets, command returned the error: "_consoleError.Read())
    do consoleError.Rewind()
  }
    
  quit sc
]]></Implementation>
</Method>

<Method name="log">
<FormalSpec>*logList:%Stream.Object</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set params = 3
  set params(1) = ..RepositoryPath
  set params(2) = ..ErrorFilePath
  set params(3) = ..OutputFilePath
  set command = ##class(Port.SourceControl.Config).GetVCSCommand("log", params...)    
  
  do $zf(-1, command)
  
  set outputBuffer = ##class(%FileCharacterStream).%New()  
  set outputBuffer.Filename = ..OutputFilePath
  
  set errorBuffer = ##class(%FileCharacterStream).%New()  
  set errorBuffer.Filename = ..ErrorFilePath
     
  set logList = ##class(%Stream.GlobalCharacter).%New()  
  
  $$$QuitOnError(logList.CopyFrom(outputBuffer))
  
  set logList.LineTerminator  = $char(10)
  
  do outputBuffer.Clear()
  do errorBuffer.Clear()
    
  if logList.Size = 0 && (logList.Size > 0) {    
    do errorBuffer.Rewind()
    set sc = $$$ERROR(5001, "Unable to show git log: "_errorBuffer.Read())
    do errorBuffer.Rewind()
  }   
  quit $$$OK
]]></Implementation>
</Method>

<Query name="Diff">
<Type>%Query</Type>
<FormalSpec>repositoryPath:%String,paths:%String,filter:%String="AMD",commit:%String="HEAD"</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Type:%String,Path:%String"/>
</Query>

<Method name="DiffFetch">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>DiffExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set index = $list(QHandle, 1)
  set index = $order(^||Port.Git.Diff(index))
  
  if index = "" {
    set Row = ""
    set AtEnd = 1
  } else {
    set Row = ^||Port.Git.Diff(index)
    set $list(Row, 1) = $listget(^||Port.Git.Diff(index), 1)
    set $list(Row, 2) = $listget(^||Port.Git.Diff(index), 2)
  }
  set QHandle = $listbuild(index)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="DiffClose">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary]]></FormalSpec>
<PlaceAfter>DiffExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set QHandle = ""
  kill ^||Port.Git.Diff
  quit $$$OK
]]></Implementation>
</Method>

<Method name="DiffExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,repositoryPath:%String,paths:%String=".",filter:%String="AMD",commit:%String="HEAD"]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set git = ..%New(repositoryPath)
  set diffs = ""
  kill ^||Port.Git.Diff
  $$$QuitOnError(git.diff(paths,filter, commit, .output, .error))
  if $isobject(output) && output.%IsA("%Stream.Object") && (output.Size > 0) {
    while 'output.AtEnd {
      set line = output.ReadLine()
      set status = $piece(line, $char(9), 1)
      set file = $piece(line, $char(9), 2)
      set ^||Port.Git.Diff($increment(i)) = $listbuild(status, file)
    }
  }
  set QHandle = $listbuild("")
  quit sc
]]></Implementation>
</Method>

<Query name="Log">
<Type>%Query</Type>
<FormalSpec>repositoryPath:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Commit:%String,Author:%String,Email:%String,Date:%String,Message:%String"/>
</Query>

<Method name="LogFetch">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>DiffExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set index = $list(QHandle, 1)
  set index = $order(^||Port.Git.Log(index), -1)
  
  if index = "" {
    set Row = ""
    set AtEnd = 1
  } else {
    set Row = ^||Port.Git.Log(index)
    set $list(Row, 1) = $listget(^||Port.Git.Log(index), 1)
    set $list(Row, 2) = $listget(^||Port.Git.Log(index), 2)
  }
  set QHandle = $listbuild(index)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="LogExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary,repositoryPath:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set git = ..%New(repositoryPath)
  set diffs = ""
  kill ^||Port.Git.Log
  $$$QuitOnError(git.log(.commits))
  if $isobject(commits) && commits.%IsA("%Stream.Object") && (commits.Size > 0) {
    while 'commits.AtEnd {
      set line = commits.ReadLine()
      set commit    = $piece(line, "||", 1)
      set author    = $piece(line, "||", 2)
      set email     = $piece(line, "||", 3)
      set authorDate = $piece(line, "||", 4)
      set authorUNIXDate = $piece(line, "||", 5)
      set subject = $piece(line, "||", 6)
      set ^||Port.Git.Log(authorUNIXDate) = $listbuild(commit, author, email, authorDate, subject)
    }
  }
  set QHandle = $listbuild("")
  quit sc
]]></Implementation>
</Method>

<Method name="LogClose">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&QHandle:%Binary]]></FormalSpec>
<PlaceAfter>DiffExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set QHandle = ""
  kill ^||Port.Git.Log
  quit $$$OK
]]></Implementation>
</Method>

<Method name="OnExport">
<FormalSpec>file:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(..add(file))
  quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.Extension.VCS">
<Super>%RegisteredObject</Super>
<TimeCreated>64306,34529.178289</TimeCreated>

<Parameter name="NAME">
<Default>Base</Default>
</Parameter>

<Parameter name="PATHS">
</Parameter>

<Property name="ErrorFilePath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="OutputFilePath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="RepositoryPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Parameters">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%OnNew">
<FormalSpec>initval:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..ErrorFilePath = ##class(%File).TempFilename()
  set ..OutputFilePath = ##class(%File).TempFilename()
  set ..RepositoryPath = ##class(%File).NormalizeFilename(initval)
  quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ##class(%File).Delete(..ErrorFilePath)
  do ##class(%File).Delete(..OutputFilePath)
]]></Implementation>
</Method>

<Method name="Install">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit $$$ERROR($$$MethodNotImplemented, "Install")
]]></Implementation>
</Method>

<Method name="OnExport">
<FormalSpec>file:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit $$$ERROR($$$MethodNotImplemented, "OnExport")
]]></Implementation>
</Method>

<Method name="OnImport">
<FormalSpec>file:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit $$$ERROR($$$MethodNotImplemented, "OnImport")
]]></Implementation>
</Method>

<Method name="SetParameter">
<FormalSpec>key,value</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    
  set ^||Port.SourceControl.VCS.Parameters(key) = value
]]></Implementation>
</Method>

<Method name="GetParameter">
<FormalSpec>key</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  quit $get(^||Port.SourceControl.VCS.Parameters(key))
]]></Implementation>
</Method>

<Method name="EvaluateDiff">
<Internal>1</Internal>
<FormalSpec>args...</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  quit 0
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.Hooks">
<Super>%Studio.SourceControl.Base</Super>
<TimeCreated>64306,34529.285329</TimeCreated>

<XData name="Menu">
<Data><![CDATA[
<MenuBase>
<Menu Name="%SourceMenu" Type="0">
<MenuItem Name="%ExportProject"/>
<MenuItem Name="%ExportProjectToXML"/>
<MenuItem Name="%ExportTestSuiteToXML"/>
<MenuItem Separator="1" />
<MenuItem Name="%RemoveProjectClasses"/>
<MenuItem Name="%RemoveProjectWebFiles"/>
<MenuItem Name="%RemoveProjectRoutines"/>
<MenuItem Separator="1" />
<MenuItem Name="%RemoveInvalidItems"/>
<MenuItem Separator="1" />
<MenuItem Name="%RunTestSuite"/>
<MenuItem Separator="1" />
<MenuItem Name="%ImportProject"/>
</Menu>
<Menu Name="%SourceContext" Type="1">
<MenuItem Name="%UpdateActiveItem" />
<MenuItem Name="%ExportActiveItem" />
<MenuItem Separator="1" />
<MenuItem Name="%RunActiveItemTest"/>
</Menu>
</MenuBase>
]]></Data>
</XData>

<Method name="OnAfterSave">
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim exporter As Port.Project.Exporter
  set projectName = $get(^||%Studio.Project)
  set sc = $$$OK
  if projectName '= "" && (projectName '[ "Default") {
    set exportPath = ##class(Port.SourceControl.Config).GetExportPath()
    set itemName = ##class(Port.SourceControl.Util).ResolveInternalName(InternalName)    
    set type = ##class(Port.Project.Helper).GetItemExtension(InternalName)
    set exporter = ##class(Port.Project.Exporter).%New(exportPath)
    if ##class(Port.SourceControl.Config).IsVCSEnabled() {
      set exporter.VCS = ##class(Port.SourceControl.Util).LinkRepositoryToVCS(exportPath)
    }
    
    if type '= "PRJ" {    
      if type = "CLS" {
        set sc = exporter.ExportClass(itemName)
      } elseif ##class(Port.Project.Helper).IsRoutine(InternalName) {
        set sc = exporter.ExportRoutine(InternalName)
      } elseif type = "PKG" {     
        set sc = exporter.ExportPackage(itemName)     
      } elseif type '= "" {
        set sc = exporter.ExportWebFile(itemName)     
      }
      $$$QuitOnError(##class(Port.SourceControl.Log).LogChange(projectName, InternalName))
    }
  }
  quit sc
]]></Implementation>
</Method>

<Method name="OnBeforeSave">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set projectName = $get(^||%Studio.Project)
  
  if projectName '= "" && (projectName [ "Default") {
    write "WARNING: This source control enforces the policy of using named projects!", !
    write "WARNING: Which means that 'Default' projects are not tracked thus not being exportable!", !
    write "WARNING: In order to export the project, you're obliged to change the name to something else than 'Default'."
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="UserAction">
<FormalSpec><![CDATA[Type:%Integer,Name:%String,InternalName:%String,SelectedText:%String,&Action:%String,&Target:%String,&Msg:%String,&Reload:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set name = $piece(Name, ",", 2)
  set isContextual = ($piece(Name, ",", 1) = "%SourceContext")
  
  if $data(^||%Studio.Project) {
    set projectName = ^||%Studio.Project
    set fullPath = ##class(Port.SourceControl.Util).GetFullItemPath(InternalName)
    set itemName = ##class(Port.SourceControl.Util).ResolveInternalName(InternalName)
    set projectPath = ##class(Port.SourceControl.Config).GetExportPath()
    set testPath = ##class(Port.SourceControl.Config).GetTestPath()
    set logLevel = ##class(Port.SourceControl.Config).GetLogLevel()   
    set vcs = ""
    
    if ##class(Port.SourceControl.Config).IsVCSEnabled() {
      set vcs = ##class(Port.SourceControl.Util).LinkRepositoryToVCS(projectPath)
    }
    
    if name = "%ExportProject" {      
      $$$QuitOnError(##class(Port.Project.Manager).Export(projectPath, logLevel,0,vcs))
    }
    if name = "%ExportProjectToXML" {
      quit ##class(Port.Project.Manager).ExportToXML(projectPath, vcs)
    }
    if name = "%ExportTestSuiteToXML" {
      quit ##class(Port.Project.Manager).ExportTestSuiteToXML(projectPath, vcs)
    }
    if name = "%RunTestSuite" {
      $$$QuitOnError(##class(Port.Project.Manager).ExportTestSuiteToXML(projectPath))
      $$$QuitOnError(##class(Port.UnitTest.Manager).DebugLoadTestSuite(testPath))
      if ##class(%File).DirectoryExists(testPath) {
        quit ##class(Port.UnitTest.Manager).DebugRunTestCase(testPath)
      }
      quit $$$OK
    }       
    if name = "%ImportProject" {
      if $isobject(vcs) {
        if $System.Event.Defined("SCCSPCOMMIT") do $System.Event.Delete("SCCSPCOMMIT")
        do $System.Event.Create("SCCSPCOMMIT")
        set Action = 2
        set Target = ##class(csp.sourcecontrol.git.commit).#CSPURL
        quit $$$OK
      } else {
        $$$QuitOnError(##class(Port.Project.Manager).Import(projectPath, logLevel, 0, 0, vcs))
      }
    }
    if name = "%RemoveProjectClasses" {
      $$$QuitOnError(##class(Port.Project.Manager).RemoveItemsFromCategory(projectName, "CLS"))
      quit ##class(Port.SourceControl.Log).Synchronize()
    }
    if name = "%RemoveProjectWebFiles" {
      $$$QuitOnError(##class(Port.Project.Manager).RemoveItemsFromCategory(projectName, "CSP"))
      quit ##class(Port.SourceControl.Log).Synchronize()
    }
    if name = "%RemoveProjectRoutines" {
      $$$QuitOnError(##class(Port.Project.Manager).RemoveItemsFromCategory(projectName, "MAC"))
      quit ##class(Port.SourceControl.Log).Synchronize()
    }
    if name = "%RemoveInvalidItems" {
      $$$QuitOnError(##class(Port.Project.Manager).RemoveInvalidItems(projectName))
      quit ##class(Port.SourceControl.Log).Synchronize()     
    }
    
    if name = "%ExportActiveItem" {
      if $$$ucase(InternalName) '= ($$$ucase(projectName_".PRJ")) {
        set exporter = ##class(Port.Project.Exporter).%New(projectPath)
        set exporter.Overwrite = 1
        set internalName = InternalName
        if $extract(InternalName, 1) = "/" {
          set internalName = $extract(InternalName, 2, $length(InternalName))
        }
        $$$QuitOnError(exporter.ExportItem(internalName))
        quit ##class(Port.SourceControl.Log).LogChange(projectName, internalName)
      } else {
        quit ##class(Port.Project.Manager).Export(projectPath, logLevel, 1, vcs)
      }
    }
    
    if name = "%UpdateActiveItem" {
      if $$$ucase(InternalName) = ($$$ucase(projectName_".PRJ")) {
        quit ##class(Port.Project.Manager).Import(projectPath, logLevel, 0, 1, vcs)
      } else {        
        quit ##class(Port.Project.Manager).ImportPartial(projectPath, fullPath, logLevel)
      }
    }
    
    if name = "%RunActiveItemTest" {
      set testable = ##class(Port.SourceControl.Util).AssertTestableClass(itemName, .testableClass)      
      if testable {
        $$$QuitOnError(##class(Port.UnitTest.Manager).DebugLoadTestSuite(testPath))
        quit ##class(Port.UnitTest.Manager).DebugRunTestCase(testPath, testableClass)
      }
    }   
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="OnMenuItem">
<FormalSpec><![CDATA[MenuName:%String,InternalName:%String,SelectedText:%String,&Enabled:%Boolean,&DisplayName:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set itemName = ##class(Port.SourceControl.Util).ResolveInternalName(InternalName)
  set menu=$piece(MenuName,","),name=$piece(MenuName,",",2)
  If menu'="%SourceMenu",menu'="%SourceContext" Quit $$$OK
  set isContextual = (menu = "%SourceContext")
  if name = "%ExportProject" {
    set DisplayName = "Exportar Projeto"
  } 
  if name = "%ExportProjectToXML" {
    set DisplayName = "Exportar Projeto para XML"
  } 
  if name = "%ExportTestSuiteToXML" {
    set DisplayName = "Exportar Suíte de Teste para XML"
  }   
  if name = "%ImportProject" {
    set DisplayName = "Importar Projeto"    
  } 
  if name = "%RemoveProjectClasses" {
    set DisplayName = "Remover Classes do Projeto"
  } 
  if name = "%RemoveProjectWebFiles" {
    set DisplayName = "Remover Arquivos Web do Projeto"
  } 
  if name = "%RemoveProjectRoutines" {
    set DisplayName = "Remover Rotinas do Projeto"
  } 
  if name = "%RemoveInvalidItems" {
    set DisplayName = "Remover Itens Inválidos do Projeto"
  }
  
  if name= "%RunTestSuite" {
    set DisplayName = "Executar Suíte de Testes"
  }
  
  if name = "%RunActiveItemTest" {
    set DisplayName = "Executar Testes deste Item"
    set Enabled = ##class(Port.SourceControl.Util).AssertTestableClass(itemName)
  } 
  
  if name = "%ExportActiveItem" {
    set DisplayName = "Exportar este item"
  }
  
  if name ="%UpdateActiveItem" {
    set DisplayName = "Importar este Item"
  }
  
  set isProjectOpened = ($get(^||%Studio.Project, "Default") '[ "Default")
  if 'isProjectOpened {
    set Enabled = 0
  }
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterCompile">
<Description>
Called after the compile of the item is done.</Description>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set projectName = $get(^||%Studio.Project)
  set sc = $$$OK
  
  if projectName '= "" && (projectName '[ "Default") {
    set projectPath = ##class(Port.SourceControl.Config).GetExportPath()
    set itemName = ##class(Port.SourceControl.Util).ResolveInternalName(InternalName)
    set type = $$$ucase($piece(InternalName, ".", $length(InternalName, ".")))    
    set exporter = ##class(Port.Project.Exporter).%New(projectPath)
    set xmlExporter = ##class(Port.Project.XMLExporter).%New(projectPath)
    
    if type = "CLS" {     
      set testPath = ##class(Port.SourceControl.Config).GetTestPath()      
      set shouldRunTest = (
        ##class(Port.SourceControl.Config).IsTestOnDemandEnabled() &&
        ##class(Port.SourceControl.Util).AssertTestableClass(itemName, .testableClass) &&
        ##class(%File).DirectoryExists(projectPath_"/"_testPath)        
      )
      if shouldRunTest {
        set activeTestableClass = InternalName
        
        do ##class(%RoutineMgr).TS(activeTestableClass, .act, .isActiveUpToDate)        
        do ##class(%RoutineMgr).TS(testableClass_".CLS", .tct, .isTestUpToDate)
                
        if 'isTestUpToDate {
          set filePath = ##class(Port.Project.Helper).ClassToFile(projectPath_"/"_testPath, testableClass)
          $$$QuitOnError(xmlExporter.ExportTest(projectPath, testableClass))
          $$$QuitOnError(##class(Port.UnitTest.Manager).DebugLoadTestSuite(testPath))
        }       
        $$$QuitOnError(##class(Port.UnitTest.Manager).DebugRunTestCase(testPath, testableClass))   
      }
    }
  }
  quit $$$OK
]]></Implementation>
</Method>

<Method name="AfterUserAction">
<FormalSpec><![CDATA[Type:%Integer,Name:%String,InternalName:%String,Answer:%Integer,Msg:%String="",&Reload:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  #dim vcs As Port.SourceControl.Extension.VCS
  set path = ##class(Port.SourceControl.Config).GetExportPath()
  set vcs = ##class(Port.SourceControl.Util).LinkRepositoryToVCS(path)  
  set logLevel = ##class(Port.SourceControl.Config).GetLogLevel()
  set msg = $System.Event.WaitMsg("SCCSPCOMMIT", 4)
  if $listget(msg, 1) '= 1 || ($listget(msg, 2) = "") {
    write "ERROR: Failed to receive required parameter. Aborting."
    quit $$$OK
  }
  do vcs.SetParameter("commit", $listget(msg, 2))
  $$$QuitOnError(##class(Port.Project.Manager).Import(path, logLevel, 0, 0, vcs))
  Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.Installer">
<Abstract>1</Abstract>
<TimeCreated>64306,34529.365286</TimeCreated>

<Method name="Install">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ##class(Port.SourceControl.Config).SetExportPath("/CacheProjects/{NAMESPACE}/{PROJECT}")	
	do ##class(Port.SourceControl.Config).SetTestPath("tests/{PROJECT}")
	do ##class(Port.SourceControl.Config).SetTestClassPrefix("UnitTest")
	do ##class(Port.SourceControl.Config).EnableTestOnDemand()
	do ##class(Port.SourceControl.Config).DisableExportOnlyAssertedClass()
	do ##class(Port.SourceControl.Config).SetLogLevel(1)
	
	$$$QuitOnError(##class(%Studio.SourceControl.Interface).SourceControlClassSet("Port.SourceControl.Hooks", $namespace))
	quit ##class(Port.SourceControl.LogCleaner).StartTask()
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.Log">
<Abstract>1</Abstract>
<TimeCreated>64306,34529.444198</TimeCreated>

<Method name="LogChange">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName=^||%Studio.Project,itemName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..ExtractNameAndNormalizedCategory(itemName, .name, .type) 
	set ^Port.SourceControl.Projects(projectName, type, name) = $zdatetime($horolog, 3,,,,,,,,,0)	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="ExtractNameAndNormalizedCategory">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName,*name="",*type=""</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set len = $length(itemName, ".")
	set type = $$$ucase($piece(itemName, ".", len))
	set name = $piece(itemName, ".", 1, len - 1)
	if '$listfind($listbuild("MAC", "INT", "INC", "CLS", "CSP", "PRJ", "MVB", "MVI", "BAS", "DFI"), type) {
		set name = itemName
		set type = "CSP"
	}
]]></Implementation>
</Method>

<Method name="GetLastChange">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,itemName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	do ..ExtractNameAndNormalizedCategory(itemName, .name, .type)
	quit $get(^Port.SourceControl.Projects(projectName, type, name), 0)
]]></Implementation>
</Method>

<Method name="Synchronize">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define ProjectExists(%id) ##class(%Studio.Project).%ExistsId(%id)
	#define ItemExists(%id) ##class(%Studio.ProjectItem).%ExistsId(%id)
	
	set sc = $$$OK
	if '$data(^Port.SourceControl.Projects) quit sc
	
	set global = "^Port.SourceControl.Projects"
	set q = $query(@global@(""))
	for {
		quit:q=""
		
		set projectName = $qsubscript(q, 1)
		set type = $qsubscript(q, 2)
		set itemName = $qsubscript(q, 3)
		
		if type '= "CLS" && (type '= "PRJ") set itemName = itemName_"."_type
		if type = "CSP" set itemName = $extract(itemName, 2, $length(itemName))
		set itemId = projectName_"||"_itemName_"||"_type
		if '$$$ProjectExists(itemName) && '$$$ItemExists(itemId) {
			kill @q
		}
		set q = $query(@q, 1)
	}
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.LogCleaner">
<Super>%SYS.Task.Definition</Super>
<TimeCreated>64306,34529.529651</TimeCreated>

<Method name="StartTask">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set taskName = "Port Log Synchronizer"
	if ##class(%SYS.Task).FindId(taskName) quit $$$OK		 
	set task = ##class(%SYS.Task).%New()
	set task.TimePeriod = 0
	set task.Description = "Removes extraneous project entries"
	set task.Name = taskName
	set task.TimePeriodEvery = 1
	set task.DailyFrequency = 1
	set task.DailyFrequencyTime = 0
	set task.DailyStartTime = 28800
	set task.DailyIncrement = 180
	set task.NameSpace = $namespace
	set task.TaskClass = $classname($this)
	quit task.%Save()
]]></Implementation>
</Method>

<Method name="OnTask">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit ##class(Port.SourceControl.Util).synchronizeLog()
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.Util">
<Abstract>1</Abstract>
<TimeCreated>64306,34529.618315</TimeCreated>

<Parameter name="DEFAULTPATH">
<Default>/CacheProjects/{NAMESPACE}/{PROJECT}</Default>
</Parameter>

<Method name="GetFullItemPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  set fullPath = ""
  set type = ##class(Port.Project.Helper).GetItemExtension(itemName)
  set defaultPath = ##class(%File).NormalizeFilename(##class(Port.SourceControl.Config).GetExportPath())
  
  if type = "CLS" {
    set fullPath = ##class(Port.Project.Helper).ClassToFile(defaultPath_"/cls", $piece(itemName, ".", 1, *))
  } elseif ##class(Port.Project.Helper).IsRoutine(itemName) {
    set ext = $$$lcase(type)
    set fileName = $$$lcase(itemName)_".txt"
    set fullPath = ##class(%File).NormalizeFilename(defaultPath_"/"_ext_"/"_fileName) 
  } elseif type = "PKG" {
    set fullPath = ##class(%File).GetDirectory(##class(Port.Project.Helper).ClassToFile(defaultPath_"/cls", itemName))
  } else {
    set sourceFilePath = $replace(itemName, $System.CSP.GetDefaultApp($namespace), "/web")    
    set fullPath = ##class(%File).NormalizeFilename(defaultPath_sourceFilePath) 
  } 
  quit fullPath
]]></Implementation>
</Method>

<Method name="ResolveInternalName">
<ClassMethod>1</ClassMethod>
<FormalSpec>internalName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set name = internalName
  if internalName '[ $System.CSP.GetDefaultApp($namespace) {
    set name = $piece(internalName, ".", 1, *)
  }
  quit name
]]></Implementation>
</Method>

<Method name="AssertTestableClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>className,*testableClass:%String=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set prefix = ##class(Port.SourceControl.Config).GetTestClassPrefix()
  set rootPackage = $piece(className, ".")  
  
  if rootPackage = prefix {
    set testableClass = className
  } elseif ##class(%Dictionary.ClassDefinition).%ExistsId(prefix_"."_className) {
    set testableClass = prefix_"."_className 
  }
  quit (testableClass '= "")
]]></Implementation>
</Method>

<Method name="LinkRepositoryToVCS">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<ReturnType>Port.SourceControl.Extension.VCS</ReturnType>
<Implementation><![CDATA[
  set handler = ##class(Port.SourceControl.Config).GetVCSHandlerName()
  set vcs = ""
  try {
    set vcs = $classmethod(handler, "%New", path)
  } catch ex {
    // Nothing here. I wouldn't do that if %New didn't triggered an exception.
    // Seriously...
  }
  quit vcs
]]></Implementation>
</Method>
</Class>


<Class name="Port.UnitTest.Manager">
<Super>%UnitTest.Manager</Super>
<TimeCreated>64306,34529.705584</TimeCreated>

<Method name="Root">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit ##class(%File).NormalizeFilename(##class(Port.SourceControl.Config).GetExportPath())
]]></Implementation>
</Method>

<Method name="PurgeLastLog">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^UnitTest.Result($order(^UnitTest.Result(""), -1))
	quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Port.UnitTest.TestCase">
<Super>%UnitTest.TestCase</Super>
<TimeCreated>64306,34529.790238</TimeCreated>

<Method name="ToAbsolutePath">
<FormalSpec>basePath:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit ##class(%File).NormalizeFilename(..Manager.Root()_"/__tests__/"_basePath)
]]></Implementation>
</Method>
</Class>


<Project name="port" LastModified="2017-01-24 16:37:13.684263" Target="##class(Port.Project.Manager).Import(&quot;/CacheProjects/DEV/rconnect-base&quot;, 1, 0, 1)" TargetType="0">
  <Items>
    <ProjectItem name="Port.Logger" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Backup" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Base" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Exporter" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Helper" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Importer" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.XMLExporter" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.Config" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.Extension.Git" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.Extension.VCS" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.Hooks" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.Installer" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.Log" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.LogCleaner" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Port.UnitTest.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="Port.UnitTest.TestCase" type="CLS"></ProjectItem>
    <ProjectItem name="portutils.INC" type="MAC"></ProjectItem>
  </Items>
  <BreakPoints>
    <BreakPoint Routine="Port.Project.Backup.CLS" Offset="Create+14"></BreakPoint>
    <BreakPoint Routine="Port.Project.Backup.CLS" Offset="Create+17"></BreakPoint>
    <BreakPoint Routine="Port.Project.Importer.CLS" Offset="GetFileExtension+5"></BreakPoint>
    <BreakPoint Routine="Port.Project.Importer.CLS" Offset="Import+27"></BreakPoint>
  </BreakPoints>
</Project>


<Routine name="portutils" type="INC"><![CDATA[
#define ImportTypes           $listbuild("INC", "INT", "CLS", "MAC", "MVI", "MVB", "BAS", "DFI", "CSR", "CSP")
#define ImportTypeDescriptions $listbuild("include files", "intermediate routines", "classes", "macro routines",  "MV Intermediate routines", "MV Basic routines", "Basic routines", "DFI XML", "CSP Rules", "files")
#define RoutineExtensions     $listbuild(".MAC", ".INT", ".INC", ".MVB", ".MVI", ".BAS", ".DFI")
]]></Routine>
</Export>
